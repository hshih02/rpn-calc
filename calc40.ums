# calc40.ums
#
# 
#
.temps r6, r7
.zero r0

.section data
        .space 10000
        endvalstack:

.section rodata
        jumptable:
        .space 256
        endjumptable:

.section init 
        r0 := 0
        r3 := endvalstack
        r5 := jumptable

init_jumptable:
        m[r0][r5] := input_error
        r5 := r5 + 1
        if (r5 != endjumptable ) goto init_jumptable using r4

        m[r0][jumptable + '0'] := digit
        m[r0][jumptable + '1'] := digit
        m[r0][jumptable + '2'] := digit
        m[r0][jumptable + '3'] := digit
        m[r0][jumptable + '4'] := digit
        m[r0][jumptable + '5'] := digit
        m[r0][jumptable + '6'] := digit
        m[r0][jumptable + '7'] := digit
        m[r0][jumptable + '8'] := digit
        m[r0][jumptable + '9'] := digit
        m[r0][jumptable + ' '] := waiting
        m[r0][jumptable + '\n'] := newline
        m[r0][jumptable + '+'] := add 
        m[r0][jumptable + '-'] := sub
        m[r0][jumptable + '*'] := mul
        m[r0][jumptable + '/'] := div
        m[r0][jumptable + '|'] := or
        m[r0][jumptable + '&'] := and
        m[r0][jumptable + 'c'] := change
        m[r0][jumptable + '~'] := complement 
        m[r0][jumptable + 's'] := swap 
        m[r0][jumptable + 'd'] := dupe
        m[r0][jumptable + 'p'] := pawp
        m[r0][jumptable + 'z'] := zerostack

        // goto m[r0][jumptable + '+']
        // goto waiting



        
.section text
main:
        push r1 on stack r2
        goto waiting linking r1
        // output "back to main\n"
        pop r1 off stack r2
        goto r1

waiting:
        // output "waiting state\n"
        // push r1 on stack r2
        r5 := input()
        push r4 on stack r2
        if (r5 == 0xFFFFFFFF) goto end_of_file using r4
        pop r4 off stack r2
        r5 := jumptable + r5
        // pop r1 off stack r2
        goto m[r0][r5]   //goto jumptable
        
end_of_file:
        // output "EOF\n"
        pop r4 off stack r2
        pop r1 off stack r2
        // output "popped all\n"
        goto r1


entering:
        // output "entering state\n"
        // push r1 on stack r2
        r5 := input()
        push r4 on stack r2
        if (r5 == 0xFFFFFFFF) goto end_of_file using r4
        pop r4 off stack r2 
        r5 := jumptable + r5
        push r4 on stack r2  // temp
        push r3 on stack r2  // temp
        if (m[r0][r5] == digit) goto multiple_digits using r4, r3
        // output "still in entering\n"
        pop r3 off stack r2  // undo using temp
        pop r4 off stack r2  // undo using temp
        // pop r1 off stack r2  // restore r1
        goto m[r0][r5]

multiple_digits:
        pop r3 off stack r2  // undo using temp
        // output "multiple digits\n"
        r5 := r5 - jumptable // revert back to raw input value
        r5 := r5 - 48  // remove ascii offset
        pop r4 off stack r3    //get previously entered digit
        r4 := r4 * 10  // increment by one tens place
        r5 := r5 + r4  // add numbers to get new multi digit value
        pop r4 off stack r2  // undo using temp
        push r5 on stack r3  //push new mutli digit value onto value stack
        goto entering

        

newline:
        // output "newline\n"
        push r1 on stack r2
        push r4 on stack r2  // temp
        // ensure there is a value to print
        if (r3 == endvalstack) goto noprint using r4 
        pop r4 off stack r2 // undo using temp

        goto print_setup linking r1
        pop r1 off stack r2
        goto waiting 

        noprint:
        // if no values to print return to waiting
        pop r4 off stack r2 // undo using temp
        pop r1 off stack r2
        goto waiting

input_error:
        push r5 on stack r2 
        r5 := r5 - jumptable
        output "Unknown character '"
        output r5
        output "'\n"
        pop r5 off stack r2
        goto waiting

check_dbl_underflow:
        // output "underflow check\n"
        // push r1 on stack r2
        push r3 on stack r2  // preserve r3
        r3 := r3 + 1 
        // ensure there are at least 2 values in value stack
        push r4 on stack r2  // temp
        if (r3 >=s endvalstack) goto fail_dbl_underflow using r4
        // output "underflow ok\n"
        pop r4 off stack r2  // undo using temp
        pop r3 off stack r2 // restore r3
        // pop r1 off stack r2
        goto r1  //return to caller

        fail_dbl_underflow:
        pop r4 off stack r2 // undo using temp
        pop r3 off stack r2 // restore r3
        pop r1 off stack r2
        output "Stack underflow---expected at least 2 elements\n"
        goto waiting  // if underflow, skip operation, return to waiting state

check_single_underflow:
        // output "underflow check\n"

        // ensure there is at least 1 value in value stack
        push r4 on stack r2  // temp
        if (r3 >=s endvalstack) goto fail_single_underflow using r4
        pop r4 off stack r2  // undo using temp

        goto r1  //return to waiting

        fail_single_underflow:
        pop r4 off stack r2 // undo using temp
        output "Stack underflow---expected at least 1 element\n"
        pop r1 off stack r2
        goto waiting  // if underflow, skip operation, return to waiting state


digit:
        // output "digit\n"
        // upon entering this function, r5 will always be the value + jumptable
        r5 := r5 - jumptable
        r5 := r5 - 48   //remove ascii offset
        push r5 on stack r3   //push digit value onto value stack
        goto entering

add:
        // output "add\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)
        r5 := r4 + r5     // x + y
        push r5 on stack r3  // push addition result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting


sub:
        // output "sub\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)
        r5 := r4 - r5     // x - y
        push r5 on stack r3  // push addition result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

mul:
        // output "mult\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)
        r5 := r4 * r5     // x * y
        push r5 on stack r3  // push mutliplication result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

div:
        // output "div\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)

        if (r5 == 0) goto div_by_zero

        push r4 on stack r2
        push r5 on stack r2
        goto check_negs

        pos_div:
        pop r3 off stack r2  // restore r3 after check negs
        r5 := r4 / r5     //  x / y
        push r5 on stack r3  // push division result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

        neg_div:
        pop r1 off stack r2 // undo using temp from check negs
        pop r3 off stack r2 // restore r3 after check negs
        r5 := r4 / r5     //  x / y
        r5 := ~r5
        r5 := r5 + 1  // convert result back to negative representation
        push r5 on stack r3  // push division result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

        div_by_zero:
        push r4 on stack r3  // restore 2nd most recent value
        push r5 on stack r3  // restore most recent value
        pop r4 off stack r2  // restore r4
        output "Division by zero\n"
        goto waiting


check_negs:
        pop r5 off stack r2
        pop r4 off stack r2

        push r3 on stack r2 // designate r3 as our flag bit
        r3 := 0   // set flag to 0, FALSE
        
        push r5 on stack r2
        r5 := r5 & 2147483648 // negative test
        if (r5 != 0) goto change_y
        pop r5 off stack r2 // restore r5 as is if not negative
        goto post_change_y

        change_y:  // if y is negative, convert to pos decimal representation
        pop r5 off stack r2 // restore r5 
        r5 := ~r5
        r5 := r5 + 1 
        r3 := r3 +1
        goto post_change_y

post_change_y:
        push r4 on stack r2
        r4 := r4 & 2147483648 // negative test
        if (r4 != 0) goto change_x
        pop r4 off stack r2 // restore r4 as is if not negative
        goto post_change_x

        change_x: // if x is negative, convert to pos decimal representation
        pop r4 off stack r2 // restore r4
        r4 := ~r4
        r4 := r4 + 1
        r3 := r3 + 1

post_change_x:

        push r1 on stack r2
        if (r3 == 1) goto neg_div using r1  // if exactly 1 negative value
        pop r1 off stack r2 // undo using temp
        goto pos_div  // in cases of no negatives or double negatives, pos div




or:
        // output "or\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)
        r5 := r4 | r5     // x | y
        push r5 on stack r3  // push or result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

and:
        // output "and\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2

        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value (y)
        pop r4 off stack r3  // r4 gets second most recent (x)
        r5 := r4 & r5     // x & y
        push r5 on stack r3  // push and result back on value stack
        pop r4 off stack r2  //restore r4
        goto waiting

change:
        push r1 on stack r2
        goto check_single_underflow linking r1
        pop r1 off stack r2
        pop r5 off stack r3
        r5 := ~r5
        r5 := r5 + 1   // convert to two's complement
        push r5 on stack r3
        goto waiting

complement:
        push r1 on stack r2
        goto check_single_underflow linking r1
        pop r1 off stack r2
        pop r5 off stack r3
        r5 := ~r5
        push r5 on stack r3
        goto waiting


swap:
        // output "swap\n"
        push r1 on stack r2
        goto check_dbl_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2
        
        push r4 on stack r2  //preserve r4
        pop r5 off stack r3  // r5 gets most recent value
        pop r4 off stack r3  // r4 gets second most recent
        push r5 on stack r3  // push top value back on first
        push r4 on stack r3  // push second most recent value on top
        pop r4 off stack r2  //restore r4
        goto waiting

dupe:
        // output "add\n"
        push r1 on stack r2
        goto check_single_underflow linking r1
        // output "returned to add\n"
        pop r1 off stack r2
        pop r5 off stack r3  // r5 gets most recent value
        push r5 on stack r3  // push value back onto stack
        push r5 on stack r3  // push value again to duplicate
        goto waiting
pawp:
        push r1 on stack r2
        goto check_single_underflow linking r1
        pop r1 off stack r2
        pop r5 off stack r3  //pop element
        goto waiting

zerostack:
        push r4 on stack r2 // temp
        if (r3 >=s endvalstack) goto exit_zerostack using r4
        pop r4 off stack r2  // undo using temp 
        pop r5 off stack r3
        goto zerostack

        exit_zerostack:
        pop r4 off stack r2  // undo using temp
        goto waiting
